"""A simple DSL for running tasks on string inputs. Built with parsing URLs in mind."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['Recipe', 'recipe_transform', 'Recipes', 'list_actions']

# %% ../nbs/00_core.ipynb 3
from fastcore.all import * 

class Recipe:
    "A recipe that can be loaded from a file and executed"
    def __init__(self, name=None, input=None, actions=None):
        store_attr()
        
    def __repr__(self): 
        return basic_repr('name,input,actions')(self)
    
    @classmethod
    def from_file(cls, path):
        "Load recipe from a .recipe file"
        p = Path(path)
        lines = p.read_text().splitlines()
        d = {}
        for line in lines:
            if ':' not in line: continue
            k,v = line.split(':', 1)
            d[k.strip()] = v.strip()
        return cls(name=p.stem, **d)

# %% ../nbs/00_core.ipynb 7
def parse_action(action_str):
    "Parse a single action string like 'func|arg1=val1,arg2=val2' into (func_name, kwargs)"
    if '|' not in action_str: return action_str.strip(), {}
    fname, args = action_str.split('|')
    fname = fname.strip()
    if not args: return fname, {}
    
    # Split only on commas that are between key=value pairs
    kwargs = {}
    current_key = None
    current_val = []

    rest = args
    while True:
        current_key, rest = rest[:args.index('=')], rest[args.index('=')+1:]
        if ',' not in rest:
            current_val = rest
            break
        else:
            comma_idx = rest.index(',')
            if comma_idx == 0:  # period is an arg
                current_val = ','
                if len(rest) == 1: break  # no more args
                else: rest = rest[2:]  # we have at least one more key=val pair to process 
            else:  # comma is not an arg but a key=val pair separator OR a value with a comma, for instance the string "a,b"
                if '=' in rest:
                    current_val, rest = rest[:comma_idx], rest[comma_idx+1:]
                    # When we find a comma before an equals in the rest of the string
                    if ',' in rest and (rest.index(',') < rest.index('=')):
                        raise ValueError(
                            f"Invalid argument format in '{args}': Found a comma before key=value pair.\n"
                            "When using multiple arguments:\n"
                            "1. Use key1=val1,key2=val2 format\n"
                            "2. Commas can only appear between key=value pairs\n"
                            "Hint: If you need commas in a value, use only one argument (key=val1,val2)"
                        )
                else:
                    current_val = rest
                    break
            #
        kwargs[current_key] = current_val
        current_key = None

    if current_key:
        kwargs[current_key] = current_val

    for value in kwargs.values():
        if '=' in value and len(kwargs) > 1:
            raise ValueError(
                f"Invalid argument format in '{args}': Found multiple equals signs in one argument.\n"
                "Arguments must be either:\n"
                "1. Single argument: func|key=any value with = or ,\n"
                "2. Multiple arguments: func|key1=val1,key2=val2\n"
                "Hint: You cannot mix these styles - choose one approach"
        )

    kwargs = {k.strip(): v.strip() for k,v in kwargs.items()}
    
    return fname, kwargs

# %% ../nbs/00_core.ipynb 10
def parse_actions(actions_str):
    "Parse a chain of actions like 'f1|a=1.f2|b=2' into a list of (func_name, kwargs)"
    return L(actions_str.split('.')).map(parse_action)

# %% ../nbs/00_core.ipynb 15
_registry = {}

def recipe_transform(name=None):
    "Decorator to register a function as a recipe transform"
    def _inner(f):
        fname = name or f.__name__
        t = Transform(f)
        t.__doc__ = f.__doc__  # Preserve the original docstring
        _registry[fname] = t
        return f
    return _inner

# %% ../nbs/00_core.ipynb 16
def get_transform(fname, kwargs):
    "Get a transform for function name with arguments"
    if fname not in _registry: 
        raise ValueError(f"Transform {fname} not found. Available: {list(_registry.keys())}")
    return partialler(_registry[fname], **kwargs)

# %% ../nbs/00_core.ipynb 19
def create_pipeline(actions_str):
    "Create a Transform pipeline from action string that handles Recipes"
    actions = parse_actions(actions_str)
    transforms = L(actions).map(lambda x: get_transform(*x))
    
    def run_pipeline(x):
        for i, t in enumerate(transforms):
            x = t(x)
            # If we get Recipes, apply remaining transforms to each recipe
            if isinstance(x, Recipes):
                remaining = '.'.join(f"{n}|{','.join(f'{k}={v}' for k,v in kw.items())}" 
                                   for n,kw in actions[i+1:])
                if remaining:
                    for r in x.recipes:
                        r.actions = remaining
                return x.run()
        return x
    
    return run_pipeline

# %% ../nbs/00_core.ipynb 20
class Recipes:
    "Collection of recipes that can be loaded from a file and executed together"
    def __init__(self, recipes=None):
        self.recipes = L(recipes if recipes else [])
    
    @classmethod
    def from_file(cls, path):
        "Load multiple recipes from a file with recipe blocks"
        p = Path(path)
        text = p.read_text()
        # Split on double newline to separate recipe blocks
        blocks = L(text.split('\n\n')).map(str.strip).filter(bool)
        
        recipes = []
        for block in blocks:
            d = {}
            for line in block.splitlines():
                if ':' not in line: continue
                k,v = line.split(':', 1)
                d[k.strip()] = v.strip()
            if d: recipes.append(Recipe(**d))
        
        return cls(recipes)
    
    def run(self, separator='\n\n'):
        "Run all recipes and combine their outputs with separator"
        return separator.join([r.run() for r in self.recipes])
    
    def __repr__(self):
        return f"Recipes({len(self.recipes)} recipes)"

# %% ../nbs/00_core.ipynb 23
@patch
def __add__(self:Recipe, other):
    "Combine two recipes, using output of self as input to other"
    name = f"{self.name}_{other.name}" if self.name and other.name else None
    actions = f"{self.actions}.{other.actions}"
    return self.__class__(name=name, input=self.input, actions=actions)    

# %% ../nbs/00_core.ipynb 26
@patch
def run(self:Recipe):
    "Execute the recipe pipeline"
    if self.input is None:
        raise ValueError("Recipe requires input to run")
    if not self.actions: return self.input
    pipe = create_pipeline(self.actions)
    return pipe(self.input)

# %% ../nbs/00_core.ipynb 28
def list_actions():
    "List all registered actions and their docstrings"
    return {name: func.__doc__ for name, func in _registry.items()}

list_actions()
